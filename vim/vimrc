""" Basics
set nocompatible     " Unset vi compatibility
syntax on            " Syntax highlighting
set background=dark  " Against a dark background
set showcmd          " Echo pending commands to the bottome of the screen
set autochdir        " Directories open relative to buffer
set showmatch        " Highlighting matching delimiters
if has('gui_running')
    set cursorline   " Highlight current line
endif
set number           " Line numbers
let mapleader = ","  " Comma for leader key
set hlsearch         " Search highlighting
set incsearch        " Incremental searching
set hidden           " Allow backgrounded changed buffers
set autoread         " Auto-reload changed files
set foldcolumn=1     " Folding column
set spelllang=en_ca  " Canadian spelling
set encoding=utf-8   " Unicode

""" Pathogen
execute pathogen#infect()
filetype plugin indent on

let $PATH .= ':' . expand('$HOME/.cabal/bin') . ':' . expand('$HOME/bin')

""" 4-space autotabs
set smartindent
set tabstop=8
set shiftwidth=4
set expandtab

""" Statusline configuration
set laststatus=2       " Turn it on
let g:airline_powerline_fonts = 1

""" Backups
set backup
set backupdir=~/.vim/backup

""" Plugin configuration
"" Unite
let g:unite_source_history_yank_enable = 1
nnoremap <Leader>p :Unite -no-split -start-insert file_rec/async<CR>
nnoremap <Leader>y :Unite -no-split -start-insert history/yank<CR>
nnoremap <Leader>b :Unite -no-split -start-insert buffer<CR>
nnoremap <Leader>m :Unite -no-split -start-insert file_mru<CR>
nnoremap <Leader>t :Unite -no-split tag<CR>

"" Neocomplete
let g:neocomplete#enable_at_startup = 1
inoremap <expr><BS> neocomplete#smart_close_popup()."\<BS>"

"" Neosnippet
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

"" Synatastic
let g:syntastic_auto_loc_list=0
let g:syntastic_auto_populate_loc_list=1
let g:syntastic_haskell_checkers = ['ghc_mod']

let g:ghcmod_ghc_options = []
let g:syntastic_haskell_ghc_mod_args = ''

"" Tagbar
let g:tagbar_type_haskell = {
    \ 'ctagsbin'  : 'hasktags',
    \ 'ctagsargs' : '-x -c -o-',
    \ 'kinds'     : [
        \  'm:modules:0:1',
        \  'd:data: 0:1',
        \  'd_gadt: data gadt:0:1',
        \  't:type names:0:1',
        \  'nt:new types:0:1',
        \  'c:classes:0:1',
        \  'cons:constructors:1:1',
        \  'c_gadt:constructor gadt:1:1',
        \  'c_a:constructor accessors:1:1',
        \  'ft:function types:1:1',
        \  'fi:function implementations:0:1',
        \  'o:others:0:1'
    \ ],
    \ 'sro'        : '.',
    \ 'kind2scope' : {
        \ 'm' : 'module',
        \ 'c' : 'class',
        \ 'd' : 'data',
        \ 't' : 'type'
    \ },
    \ 'scope2kind' : {
        \ 'module' : 'm',
        \ 'class'  : 'c',
        \ 'data'   : 'd',
        \ 'type'   : 't'
    \ }
\ }

""" Filetype-specific settings
"" Haskell
au FileType haskell nnoremap <buffer> <F5> :GhcModType<CR>
au FileType haskell nnoremap <buffer> <silent> <F6> :GhcModTypeClear<CR>
au FileType haskell nnoremap <buffer> <silent> <F7> :GhcModInfo<CR>

"" Makefiles
" Proper tabs
autocmd FileType make setlocal noexpandtab

"" Commit messages
autocmd FileType gitcommit setlocal spell

""" Keybindings
" ,<Space> for toggling folds
nnoremap <Leader><Space> za

" ,s inserts type signature
nnoremap <Leader>s :GhcModTypeInsert<CR>

" ,T to find the tags file
nnoremap <Leader>T :set tags=./tags;/<CR>

" C-h clears highlighting
nnoremap <C-h> :nohl<CR>
inoremap <C-h> <C-o>:nohl<CR>

" C-j inserts newline (thanks, brief Emacs experiment!)
inoremap <C-j> <CR>

" F2 to toggle paste mode
nnoremap <F2> :set invpaste paste?<CR>
set pastetoggle=<F2>
set showmode

"" F3 highlights trailing whitespace
nnoremap <F3> :match ErrorMsg '\s\+$'<CR>

" F4 strips trailing whitespace (clobbers the mark at 'z')
nnoremap <silent> <F4> mz:let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar>:nohl<CR>`z
vnoremap <silent> <F4> :s/\s\+$//<CR>:nohl<CR>

" F5 -- F7 taken by Haskell specific functions

" F8 to fix the Macvim fullscreen bug
nnoremap <F8> :set lines=999<CR>

" F9 toggles the tagbar
nnoremap <F9> :TagbarToggle<CR>

" F10 toggles spelling
nnoremap <F10> :setlocal spell!<CR>
inoremap <F10> <C-o>:setlocal spell!<CR>

""" Misc hacks.
"" Preserve selection after indenting
vnoremap > ><CR>gv
vnoremap < <<CR>gv

"" New files open with template
autocmd! BufNewFile * silent! 0r ~/.vim/skel/tmpl.%:e

"" Autoreload vimrc file
"  Note that the arg is 'vimrc', not '.vimrc' because of symlinking.
autocmd! BufWritePost vimrc source $MYVIMRC

"" :w!! sudo writes
cmap w!! w !sudo tee > /dev/null %

"" Regex-based alignment (thanks again, Emacs!)
command! -nargs=? -range Align <line1>,<line2>call AlignSection('<args>')
vnoremap <silent> <Leader>a :Align<CR>
function! AlignSection(regex) range
  let extra = 1
  let sep = empty(a:regex) ? '=' : a:regex
  let maxpos = 0
  let section = getline(a:firstline, a:lastline)
  for line in section
    let pos = match(line, ' *'.sep)
    if maxpos < pos
      let maxpos = pos
    endif
  endfor
  call map(section, 'AlignLine(v:val, sep, maxpos, extra)')
  call setline(a:firstline, section)
endfunction

function! AlignLine(line, sep, maxpos, extra)
  let m = matchlist(a:line, '\(.\{-}\) \{-}\('.a:sep.'.*\)')
  if empty(m)
    return a:line
  endif
  let spaces = repeat(' ', a:maxpos - strlen(m[1]) + a:extra)
  return m[1] . spaces . m[2]
endfunction
