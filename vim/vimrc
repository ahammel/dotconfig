""" Basics set nocompatible     " Unset vi compatibility
syntax on            " Syntax highlighting
set showcmd          " Echo pending commands to the bottome of the screen
set showmode
set autochdir        " Directories open relative to buffer
autocmd BufEnter * silent! lcd %:p:h
set showmatch        " Highlighting matching delimiters
if has('gui_running')
    set cursorline   " Highlight current line
else
    set nocursorline
endif
set number           " Line numbers
let mapleader = ","  " Comma for leader key
set hlsearch         " Search highlighting
set incsearch        " Incremental searching
set hidden           " Allow backgrounded changed buffers
set autoread         " Auto-reload changed files
set foldcolumn=1     " Folding column
set spelllang=en_ca  " Canadian spelling
set encoding=utf-8   " Unicode

""" Pathogen
execute pathogen#infect()
filetype plugin indent on

let $PATH =  '/usr/local/bin/:' . expand('$HOME/.cabal/bin') . ':' . expand('$HOME/bin') . ':' . $PATH

""" 4-space autotabs
set smartindent
set tabstop=4
set shiftwidth=4
set expandtab

""" List trailing whitespace chars
set listchars=tab:>>,trail:_
set list

""" Statusline configuration
set laststatus=2       " Turn it on
set statusline=%t      " Tail of filename
set statusline+=%m     " Modified flag
set statusline+=%=     " Left/right separator
set statusline+=%c,    " Cursor column
set statusline+=%l/%L  " Cursor line / total lines

""" Backups
set backup
set backupdir=~/.vim/backup

""" Plugin configuration
"" Unite
let g:unite_source_history_yank_enable = 1
let g:unite_source_rec_async_command =
 \ ['ag', '-p', '~/.agignore',
 \ '--nocolor', '--nogroup', '--hidden',
 \ '-g', '']
nnoremap <Leader>p :Unite -no-split -start-insert file_rec/async:!<CR>
nnoremap <Leader>b :Unite -no-split -start-insert buffer<CR>
nnoremap <Leader>m :Unite -no-split -start-insert file_mru<CR>
nnoremap <Leader>t :Unite -no-split tag<CR>

"" Synatastic
let g:syntastic_auto_loc_list=0
let g:syntastic_auto_populate_loc_list=1
let g:syntastic_haskell_checkers = ['hlint']
let g:syntastic_python_checkers = ['python', 'pyflakes']

let g:syntastic_haskell_hlint_args = "--hint=$HOME/HLint.hs"

nnoremap <Leader>st :SyntasticToggleMode<CR>

"" Neocomplete
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case=1
let g:neocomplete#sources#syntax#min_keyword_length=3

autocmd CursorMovedI * if pumvisible() == 0|pclose|endif
autocmd InsertLeave * if pumvisible() == 0|pclose|endif

"" Neosnippet
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

autocmd FileType neosnippet setlocal noexpandtab

" Vim-slime
let g:slime_target = "tmux"
let g:slime_python_ipython = 1


"" Tagbar
let g:tagbar_type_haskell = {
    \ 'ctagsbin'  : 'hasktags',
    \ 'ctagsargs' : '-x -c -o-',
    \ 'kinds'     : [
        \  'm:modules:0:1',
        \  'd:data: 0:1',
        \  'd_gadt: data gadt:0:1',
        \  't:type names:0:1',
        \  'nt:new types:0:1',
        \  'c:classes:0:1',
        \  'cons:constructors:1:1',
        \  'c_gadt:constructor gadt:1:1',
        \  'c_a:constructor accessors:1:1',
        \  'ft:function types:1:1',
        \  'fi:function implementations:0:1',
        \  'o:others:0:1'
    \ ],
    \ 'sro'        : '.',
    \ 'kind2scope' : {
        \ 'm' : 'module',
        \ 'c' : 'class',
        \ 'd' : 'data',
        \ 't' : 'type'
    \ },
    \ 'scope2kind' : {
        \ 'module' : 'm',
        \ 'class'  : 'c',
        \ 'data'   : 'd',
        \ 'type'   : 't'
    \ }
\ }

"" Yaml
autocmd Filetype yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2

"" Makefiles
" Proper tabs
autocmd FileType make setlocal noexpandtab

"" Commit messages
autocmd FileType gitcommit setlocal spell

""" Keybindings
" ,<Space> for toggling folds
nnoremap <Leader><Space> za

"" Haskell commands
" ,hs inserts type signature
nnoremap <Leader>hs :GhcModTypeInsert<CR>

" ,hl hlints the current file
nnoremap <Leader>hl :SyntasticCheck hlint<CR>

" ,T to find the tags file
nnoremap <Leader>T :set tags=./tags;/<CR>

" C-h clears highlighting
nnoremap <C-h> :nohl<CR>
inoremap <C-h> <C-o>:nohl<CR>

" C-j inserts newline (thanks, brief Emacs experiment!)
inoremap <C-j> <CR>

" F2 to toggle paste mode
nnoremap <F2> :set invpaste paste?<CR>
set pastetoggle=<F2>

"" F3 highlights trailing whitespace
nnoremap <F3> :match ErrorMsg '\s\+$'<CR>

" F4 strips trailing whitespace (clobbers the mark at 'z')
nnoremap <silent> <F4> mz:let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar>:nohl<CR>`z
vnoremap <silent> <F4> :s/\s\+$//<CR>:nohl<CR>

" F5 toggles spelling
nnoremap <F5> :setlocal spell!<CR>
inoremap <F5> <C-o>:setlocal spell!<CR>

" F9 toggles the tagbar
nnoremap <F9> :TagbarToggle<CR>


" Meta-D to go to beginning of line in insert mode
if (system("uname -s") =~ "Darwin")
    inoremap âˆ‚ <C-o>0
else
    inoremap <M-d> <C-o>0
endif

""" Misc hacks.
"" Preserve selection after indenting
vnoremap > ><CR>gv
vnoremap < <<CR>gv

"" New files open with template
autocmd! BufNewFile * silent! 0r ~/.vim/skel/tmpl.%:e

"" Autoreload vimrc file
"  Note that the arg is 'vimrc', not '.vimrc' because of symlinking.
autocmd! BufWritePost vimrc source $MYVIMRC

"" :w!! sudo writes
cmap w!! w !sudo tee > /dev/null %

"" Regex-based alignment (thanks again, Emacs!)
command! -nargs=? -range Align <line1>,<line2>call AlignSection('<args>')
vnoremap <silent> <Leader>a :Align<CR>
function! AlignSection(regex) range
  let extra = 1
  let sep = empty(a:regex) ? '=' : a:regex
  let maxpos = 0
  let section = getline(a:firstline, a:lastline)
  for line in section
    let pos = match(line, ' *'.sep)
    if maxpos < pos
      let maxpos = pos
    endif
  endfor
  call map(section, 'AlignLine(v:val, sep, maxpos, extra)')
  call setline(a:firstline, section)
endfunction

function! AlignLine(line, sep, maxpos, extra)
  let m = matchlist(a:line, '\(.\{-}\) \{-}\('.a:sep.'.*\)')
  if empty(m)
    return a:line
  endif
  let spaces = repeat(' ', a:maxpos - strlen(m[1]) + a:extra)
  return m[1] . spaces . m[2]
endfunction

" Search for selected text, forwards or backwards.
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>

" Qargs dumps the quickfix list into args
command! -nargs=0 -bar Qargs execute 'args ' . QuickfixFilenames()
function! QuickfixFilenames()
    " Building a hash ensures we get each buffer only once
    let buffer_numbers = {}
    for quickfix_item in getqflist()
        let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
    endfor
    return join(values(buffer_numbers))
endfunction

""" Macros
"" @b draws a box of octothorpes around the text on the line (centred)
let @b=':centeroâˆ‚74i#kkjOâˆ‚74i#j0r#74A 74|C#jj'

"" @h inserts a stub haskell function if the cursor is on a typed hole
let @h='yE:Errorjj/"v/Relevant bindings includeyGo"'
